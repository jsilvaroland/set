{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/javascripts/board.js","webpack:///./src/javascripts/card.js","webpack:///./src/javascripts/deck.js","webpack:///./src/javascripts/entry.js","webpack:///./src/javascripts/game.js","webpack:///./src/javascripts/set.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAA0B;;AAE1B;AACA,EAAE,eAAe;AACjB,EAAE,gBAAgB;AAClB,EAAE,gBAAgB;AAClB,EAAE,gBAAgB;AAClB,EAAE,iBAAiB;AACnB,EAAE,iBAAiB;AACnB,EAAE,gBAAgB;AAClB,EAAE,iBAAiB;AACnB,EAAE,iBAAiB;AACnB,EAAE,gBAAgB;AAClB,EAAE,iBAAiB;AACnB,EAAE;AACF;;AAEA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,kBAAkB,6CAAI;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,MAAM;AACf,SAAS,OAAO;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,MAAM;AACf,SAAS,OAAO;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,MAAM;AACf,WAAW,OAAO;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB;AACrB,WAAW,YAAY;AACvB;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA,sBAAsB;AACtB;AACA;AACA;AACA,GAAG;AACH,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD;;AAEA,wBAAwB;AACxB;AACA,UAAU,OAAO;AACjB;AACA,GAAG;AACH;AACA;;AAEA;AACA,SAAS,MAAM;AACf,SAAS,OAAO;;AAEhB;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;;AAEA;AACA,SAAS,MAAM;;AAEf;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;;AAEA;AACA,SAAS,MAAM;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,E;;;;;;;;;;;;ACtMpB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;ACXnB;AAAA;AAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,iCAAiC,MAAM,GAAG,OAAO,GAAG,MAAM;;AAE1D,gBAAgB,6CAAI;AACpB;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM,GAAG,OAAO,GAAG,MAAM,GAAG,QAAQ;;AAEtE,iBAAiB,6CAAI;AACrB;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;AAEA;AACA,SAAS,OAAO;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;ACnFnB;AAAA;AAAwB;;AAExB;AACA;;AAEA;AACA;AACA,oBAAoB,4CAAG;;AAEvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,IAAI;;;;;;;;;;;;;ACvBJ;AAAA;AAA4B;;AAE5B;AACA;AACA,mBAAmB,8CAAK;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,QAAQ;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,UAAU,eAAe;;AAEzB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,sBAAsB;;AAE/B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;;AAEA;AACA,OAAO,QAAQ;AACf;AACA,iBAAiB,kBAAkB;AACnC;AACA,sBAAsB,kBAAkB;AACxC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;ACnNnB;AAAA;AAA0B;;AAE1B;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;;AAEA;AACA;;AAEA;AACA;;AAEe,kEAAG,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/javascripts/entry.js\");\n","import Deck from './deck';\n\nconst CARD_COORDS = [\n\t{ x: 50, y: 50 },\n\t{ x: 262, y: 50 },\n\t{ x: 474, y: 50 },\n\t{ x: 50, y: 202 },\n\t{ x: 262, y: 202 },\n\t{ x: 474, y: 202 },\n\t{ x: 50, y: 354 },\n\t{ x: 262, y: 354 },\n\t{ x: 474, y: 354 },\n\t{ x: 50, y: 507 },\n\t{ x: 262, y: 507 },\n\t{ x: 474, y: 507 }\n];\n\nclass Board {\n  constructor(ctx, canvas, difficulty) {\n\t\tthis.ctx = ctx;\n\t\tthis.dimensions = { width: canvas.width, height: canvas.height };\n\n\t\tthis.board = [];\n\t\tthis.deck = new Deck(difficulty);\n\t\tthis.resetCanvas();\n\t\tthis.initialDisplayCards();\n\t\tthis.displayDeckCount();\n\t\tthis.displaySetsFound(0);\n\t}\n\t\n\tresetCanvas() {\n\t\tthis.ctx.clearRect(0, 0, this.dimensions.width, this.dimensions.height);\n\t}\n\n\tclearCardArea(x, y) {\n\t\tthis.ctx.clearRect(x-3, y-3, 197 + 3, 137 + 3); // clears area\n\t}\n\n\tremoveCard(card) {\n\t\tconst i = this.board.indexOf(card);\n\t\tdelete this.board[i];\n\t}\n\n\thighlight(card) {\n\t\tconst { ctx } = this;\n\t\tconst { x, y } = card.pos;\n\n\t\tthis.clearCardArea(x, y);\n\t\tctx.beginPath();\n    ctx.moveTo(x + 10, y);\n    ctx.lineTo(x + 185, y);\n    ctx.quadraticCurveTo(x + 195, y, x + 195, y + 10);\n    ctx.lineTo(x + 195, y + 125);\n    ctx.quadraticCurveTo(x + 195, y + 135, x + 185, y + 135);\n    ctx.lineTo(x + 10, y + 135);\n    ctx.quadraticCurveTo(x, y + 135, x, y + 125);\n    ctx.lineTo(x, y + 10);\n    ctx.quadraticCurveTo(x, y, x + 10, y);\n\t\tctx.strokeStyle = \"#959595\";\n\t\tctx.fillStyle = \"#DDEFFE\";\n\t\tctx.lineWidth = 3; // maybe change this\n\t\tthis.ctx.stroke();\n\t\tthis.ctx.fill();\n\n\t\tthis.drawCardImage(card.card, card.pos);\n\t}\n\n\tunhighlight(card) {\n\t\tconst { ctx } = this;\n\t\tconst { x, y } = card.pos;\n\n\t\tthis.clearCardArea(x, y);\n\t\tctx.beginPath();\n    ctx.moveTo(x + 10, y);\n    ctx.lineTo(x + 185, y);\n    ctx.quadraticCurveTo(x + 195, y, x + 195, y + 10);\n    ctx.lineTo(x + 195, y + 125);\n    ctx.quadraticCurveTo(x + 195, y + 135, x + 185, y + 135);\n    ctx.lineTo(x + 10, y + 135);\n    ctx.quadraticCurveTo(x, y + 135, x, y + 125);\n    ctx.lineTo(x, y + 10);\n\t\tctx.quadraticCurveTo(x, y, x + 10, y);\n\t\tctx.strokeStyle = \"#959595\";\n\t\tctx.fillStyle = \"#FFFFFF\";\n\t\tctx.lineWidth = 3;\n\t\tthis.ctx.stroke();\n\t\tthis.ctx.fill();\n\n\t\tthis.drawCardImage(card.card, card.pos);\n\t}\n\n\terrorHighlight(card) {\n\t\tconst { ctx } = this;\n    const { x, y } = card.pos;\n\n    this.clearCardArea(x, y);\n    ctx.beginPath();\n    ctx.moveTo(x + 10, y);\n    ctx.lineTo(x + 185, y);\n    ctx.quadraticCurveTo(x + 195, y, x + 195, y + 10);\n    ctx.lineTo(x + 195, y + 125);\n    ctx.quadraticCurveTo(x + 195, y + 135, x + 185, y + 135);\n    ctx.lineTo(x + 10, y + 135);\n    ctx.quadraticCurveTo(x, y + 135, x, y + 125);\n    ctx.lineTo(x, y + 10);\n    ctx.quadraticCurveTo(x, y, x + 10, y);\n    ctx.strokeStyle = \"#959595\";\n    ctx.fillStyle = \"#FEDDDF\";\n    ctx.lineWidth = 3;\n    this.ctx.stroke();\n    this.ctx.fill();\n\n    this.drawCardImage(card.card, card.pos);\n\t}\n\n  displayCard(x, y) { // displays a single card\n    const { ctx, deck } = this;\n\t\tconst card = deck.deal();\n\t\tconst pos = { x, y };\n\n    ctx.beginPath();\n    ctx.moveTo(x + 10, y);\n    ctx.lineTo(x + 185, y);\n    ctx.quadraticCurveTo(x + 195, y, x + 195, y + 10);\n    ctx.lineTo(x + 195, y + 125);\n    ctx.quadraticCurveTo(x + 195, y + 135, x + 185, y + 135);\n    ctx.lineTo(x + 10, y + 135);\n    ctx.quadraticCurveTo(x, y + 135, x, y + 125);\n    ctx.lineTo(x, y + 10);\n\t\tctx.quadraticCurveTo(x, y, x + 10, y);\n\t\tctx.strokeStyle = \"#959595\";\n\t\tctx.fillStyle = \"#FFFFFF\";\n\t\tctx.lineWidth = 3;\n\t\tthis.ctx.stroke();\n\t\tthis.ctx.fill();\n\n\t\tif (this.board.includes(undefined)) {\n\t\t\tfor (let i = 0; i < this.board.length; i++) {\n\t\t\t\tif (typeof this.board[i] == 'undefined') {\n\t\t\t\t\tthis.board[i] = { pos, card };\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.drawCardImage(card, pos);\n\t\t} else {\n\t\t\tthis.board.push({ pos, card });\n\t\t\tcard.image.onload = () => {\n\t\t\t\tthis.drawCardImage(card, pos);\n\t\t\t};\n\t\t}\n\t\t\n\t\t// card.image.onload = () => {\n\t\t// \tthis.drawCardImage(card, pos);\n\t\t// };\n\t}\n\t\n\tdrawCardImage(card, pos) {\n\t\tthis.ctx.drawImage(card.image, pos.x + 28, pos.y + 25); // modify x and y later to center images\n\t}\n\n\tinitialDisplayCards() { // displays all 12 cards\n\t\tCARD_COORDS.forEach(coords => {\n\t\t\tconst { x, y } = coords;\n\t\t\tthis.displayCard(x, y);\n\t\t});\n\t\tconsole.log(this.board);\n\t}\n\t\n\tdisplayDeckCount() {\n\t\tconst { ctx } = this;\n\t\tconst { deck } = this.deck;\n\n\t\tthis.ctx.clearRect(0, 0, 200, 40);\n\t\tctx.font = '20px Arial';\n\t\tctx.fillStyle = '#000000';\n\t\tthis.ctx.fillText(`Deck: ${deck.length}`, 50, 20);\n\t\tctx.fillStyle = '#FFFFFF';\n\t}\n\n\tdisplaySetsFound(setsFound) {\n\t\tconst { ctx } = this;\n\n\t\tthis.ctx.clearRect(200, 0, 200, 40);\n\t\tctx.fillStyle = '#000000';\n\t\tthis.ctx.fillText(`Sets Found: ${setsFound}`, 200, 20);\n\t\tctx.fillStyle = '#FFFFFF';\n\t}\n\n\tdrawWin() {\n\t\tconst { ctx } = this;\n\n\t\tctx.font = '100px Arial';\n\t\tctx.fillStyle = \"#000000\";\n\t\tthis.ctx.fillText(`You Win!`, 250, 400);\n\t\t// change these coordinates later\n\t\tctx.fillStyle = \"#FFFFFF\";\n\t}\n}\n\nexport default Board;","class Card {\n    constructor(color, number, shape, shading, image) {\n        this.color = color;\n        this.number = number;\n        this.shape = shape;\n        this.shading = shading;\n        this.image = image;\n        this.highlighted = false;\n    }\n}\n\nexport default Card;","import Card from './card';\n\nconst ATTRIBUTES = {\n\tcolors: ['red', 'green', 'purple'],\n\tnumbers: ['one', 'two', 'three'],\n\tshapes: ['oval', 'squiggle', 'diamond'],\n\tshadings: ['solid', 'striped', 'open'],\n};\n\nclass Deck {\n\tconstructor(difficulty) {\n\t\tif (difficulty === 'expert') {\n\t\t\tthis.resetDeckExpert(); // for now deck will be made in constructor, once novice mode is introduced, resetDeck will be removed from constructor and will have to be called depending on button push\n\t\t} else {\n\t\t\tthis.resetDeckNovice();\n\t\t}\n\t}\n\n\trepopulateDeckNovice() {\n\t// empties deck if not already empty\n\t\tthis.deck = [];\n\t\tlet image, card;\n\t\tlet shading = { shading: 'solid' };\n\n\t\tATTRIBUTES.colors.forEach(color => {\n\t\t\tATTRIBUTES.numbers.forEach(number => {\n\t\t\t\tATTRIBUTES.shapes.forEach(shape => {\n\t\t\t\t\timage = new Image();\n\t\t\t\t\timage.src = `./src/assets/${color}-${number}-${shape}-solid.png`;\n\n\t\t\t\t\tcard = new Card(color, number, shape, shading, image);\n\t\t\t\t\tthis.deck.push(card);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\trepopulateDeckExpert() {\n\t\t// empties deck if not already empty\n\t\tthis.deck = [];\n\t\tlet image, card;\n\n\t\tATTRIBUTES.colors.forEach(color => {\n\t\t\tATTRIBUTES.numbers.forEach(number => {\n\t\t\t\tATTRIBUTES.shapes.forEach(shape => {\n\t\t\t\t\tATTRIBUTES.shadings.forEach(shading => {\n\t\t\t\t\t\timage = new Image();\n\t\t\t\t\t\timage.src = `./src/assets/${color}-${number}-${shape}-${shading}.png`;\n\n\t\t\t\t\t\tcard = new Card(color, number, shape, shading, image);\n\t\t\t\t\t\tthis.deck.push(card);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tshuffle() {\n\t\tconst { deck } = this;\n\t\tlet count = deck.length;\n\t\tlet i;\n\n\t\twhile (count) {\n\t\t\ti = Math.floor(Math.random() * count--);\n\t\t\t[deck[count], deck[i]] = [deck[i], deck[count]];\n\t\t}\n\t}\n\n\tresetDeckNovice() {\n\t\tthis.repopulateDeckNovice();\n\t\tthis.shuffle();\n\t}\n\n\tresetDeckExpert() {\n\t\tthis.repopulateDeckExpert();\n\t\tthis.shuffle();\n\t}\n\n\tdeal() {\n\t\treturn this.deck.pop();\n\t}\n}\n\nexport default Deck;","import Set from './set';\n\n//testing \n// end testing\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const canvas = document.getElementById(\"set-game\");\n    const set = new Set(canvas);\n    \n    const newGameNovice = document.getElementById(\"new-game-novice\");\n    newGameNovice.addEventListener(\"click\", () => {\n      set.newGameNovice();\n    });\n\n    const newGameExpert = document.getElementById(\"new-game-expert\");\n    newGameExpert.addEventListener(\"click\", () => {\n      set.newGameExpert();\n    });\n});\n\n// document.addEventListener('click', () => {\n//     const newGame = document.getElementById(\"new-game\");\n//     console.log('hello');\n// });\n","import Board from './board';\n\nclass Game {\n\tconstructor(ctx, canvas, difficulty) {\n\t\tthis.board = new Board(ctx, canvas, difficulty);\n\t\tthis.clickedCards = [];\n\t\tthis.setsFound = 0;\n\t\tthis.difficulty = difficulty;\n\t}\n\n\taddGameEventListeners(canvas) {\n\t\tthis.callback = e => this.handleClick(e);\n\t\tcanvas.addEventListener('click', this.callback);\n\t}\n\n\tremoveGameEventListeners(canvas) {\n\t\tcanvas.removeEventListener('click', this.callback);\n\t}\n\n\thandleClick(e) {\n\t\tconst clickPos = { x: e.layerX, y: e.layerY };\n\t\tconst clickedCard = this.findClickedCard(clickPos);\n\n\t\tif (clickedCard) {\n\t\t\tif (this.clickedCards.includes(clickedCard)) { // if card has already been clicked\n\t\t\t\tthis.clickedCards = this.clickedCards.filter(card => card !== clickedCard);\n\t\t\t\tthis.board.unhighlight(clickedCard);\n\t\t\t} else {\n\t\t\t\tthis.clickedCards.push(clickedCard);\n\t\t\t\tthis.board.highlight(clickedCard);\n\t\t\t}\n\t\t\tthis.checkClickedCards();\n\t\t}\n\t\tconsole.log(this.clickedCards);\n\t}\n\n\tfindClickedCard(clickPos) {\n\t\tlet { board } = this.board;\n\n\t\treturn board.find(card => {\n\t\t\tif (card) {\n\t\t\t\treturn (\n\t\t\t\t\tclickPos.x >= card.pos.x &&\n\t\t\t\t\tclickPos.x < card.pos.x + 197 &&\n\t\t\t\t\tclickPos.y >= card.pos.y &&\n\t\t\t\t\tclickPos.y < card.pos.y + 137\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tcheckClickedCards() {\n\t\tif (this.clickedCards.length === 3) {\n\t\t\tconst { clickedCards } = this;\n\n\t\t\tif(this.isSet(clickedCards[0], clickedCards[1], clickedCards[2])) {\n\t\t\t\tthis.setFound();\n\t\t\t} else {\n\t\t\t\tthis.notASet();\n\t\t\t}\n\t\t\tthis.clickedCards = [];\n\t\t}\n\t}\n\n\tsetFound() {\n\t\tthis.setsFound++;\n\t\tconsole.log('is a set!');\n\t\tlet cardPosX, cardPosY;\n\t\tthis.clickedCards.forEach(card => {\n\t\t\tcardPosX = card.pos.x;\n\t\t\tcardPosY = card.pos.y;\n\t\t\tthis.board.clearCardArea(cardPosX, cardPosY);\n\t\t\tthis.board.removeCard(card);\n\t\t\t// if deck has cards left, displayCard\n\t\t\tif (this.board.deck.deck.length) {\n\t\t\t\tthis.board.displayCard(cardPosX, cardPosY);\n\t\t\t}\n\t\t});\n\t\tconsole.log(this.board.board);\n\t\tthis.board.displayDeckCount();\n\t\tthis.board.displaySetsFound(this.setsFound);\n\t\t// check if deck is empty and if any sets on board. if not, game over you win!\n\t\t\n\t\tif (this.isBoardEmpty() || (this.isDeckEmpty() && !this.anySetsOnBoard())) {\n\t\t\tconsole.log(\"you win\");\n\t\t\tthis.win();\n    }\n\t}\n\n\tisDeckEmpty() {\n\t\treturn !this.board.deck.deck.length;\n\t}\n\n\tisBoardEmpty() {\n\t\treturn !this.board.board.some(card => card);\n\t}\n\n\tnotASet() {\n\t\tconst { board, clickedCards } = this;\n\n\t\tconsole.log('not a set');\n\t\tclickedCards.forEach((card) => {\n\t\t\tthis.board.errorHighlight(card);\n\t\t\t//display message \"NOT A SET\"\n\t\t});\n\t\tsetTimeout(function() {\n\t\t\tclickedCards.forEach(card => {\n\t\t\t\tboard.unhighlight(card);\n\t\t\t\t// unhighlight THE 3 CARDS, display message \"NOT A SET\"\n\t\t\t});\n\t\t}, 250);\n\t\t// add 30 seconds to timer\n\t}\n\n\tisSet(card1, card2, card3) {\n\t\tlet colorReq = false;\n    let numberReq = false;\n    let shapeReq = false;\n    let shadingReq = false;\n\n    // color req\n    if (\n      card1.card.color === card2.card.color &&\n      card2.card.color === card3.card.color\n    ) {\n      console.log(\"all cards same color\");\n      colorReq = true;\n    } else if (\n      card1.card.color !== card2.card.color &&\n      card1.card.color !== card3.card.color &&\n      card2.card.color !== card3.card.color\n    ) {\n      console.log(\"all cards diff color\");\n      colorReq = true;\n    }\n\n    // number req\n    if (\n      card1.card.number === card2.card.number &&\n      card2.card.number === card3.card.number\n    ) {\n      numberReq = true;\n    } else if (\n      card1.card.number !== card2.card.number &&\n      card1.card.number !== card3.card.number &&\n      card2.card.number !== card3.card.number\n    ) {\n      numberReq = true;\n    }\n\n    // shape req\n    if (\n      card1.card.shape === card2.card.shape &&\n      card2.card.shape === card3.card.shape\n    ) {\n      shapeReq = true;\n    } else if (\n      card1.card.shape !== card2.card.shape &&\n      card1.card.shape !== card3.card.shape &&\n      card2.card.shape !== card3.card.shape\n    ) {\n      shapeReq = true;\n    }\n\n    // shading req\n    if (\n      card1.card.shading === card2.card.shading &&\n      card2.card.shading === card3.card.shading\n    ) {\n      shadingReq = true;\n    } else if (\n      card1.card.shading !== card2.card.shading &&\n      card1.card.shading !== card3.card.shading &&\n      card2.card.shading !== card3.card.shading\n    ) {\n      shadingReq = true;\n\t\t}\n\t\t\n\t\treturn colorReq && numberReq && shapeReq && shadingReq; // returns true if it's a set\n\t}\n\n\tanySetsOnBoard() {\n\t\tlet { board } = this.board;\n\t\t// iterate through board, all combinations of 3 cards\n\t\tfor (let i = 0; i < board.length; i++) {\n\t\t\tconst card1 = board[i];\n\t\t\tfor (let j = i + 1; j < board.length; j++) {\n\t\t\t\tconst card2 = board[j];\n\t\t\t\tfor (let k = j + 1; k < board.length; k++) {\n\t\t\t\t\tconst card3 = board[k];\n\t\t\t\t\tif (!card1 || !card2 || !card3) {\n\t\t\t\t\t\tconsole.log('spot is empty');\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (this.isSet(card1, card2, card3)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tincreaseTimer() {\n\t\t// increases timer, likely will call within newGame\n\t}\n\n\twin() {\n\t\tthis.board.drawWin();\n\t}\n}\n\nexport default Game;","import Game from './game';\n\nclass Set {\n  constructor(canvas) {\n    this.ctx = canvas.getContext(\"2d\");\n    this.canvas = canvas;\n    this.dimensions = { width: canvas.width, height: canvas.height };\n  }\n\n  newGameExpert() {\n    if (this.game) {\n      this.game.removeGameEventListeners(this.canvas);\n    }\n    this.game = new Game(this.ctx, this.canvas, 'expert');\n    this.game.addGameEventListeners(this.canvas);\n\n    // remove menu onClicks\n  }\n\n  newGameNovice() {\n    if (this.game) {\n      this.game.removeGameEventListeners(this.canvas);\n    }\n    this.game = new Game(this.ctx, this.canvas, 'novice');\n    this.game.addGameEventListeners(this.canvas);\n\n    // remove menu onClicks\n  }\n\n  // menu stuff will go here later on\n}\n\nexport default Set;"],"sourceRoot":""}